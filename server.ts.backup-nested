import express from 'express';
import session from 'express-session';
import Knex from 'knex';
import passport from 'passport';
import cors from 'cors';
import { createServer } from 'http';
import { eq } from 'drizzle-orm';
import { storage } from './storage';
import quotaManager from './quota-manager';
import postScheduler from './post-scheduler';
import twilioService from './twilio-service';
import { oauthService } from './oauth-service';
import bcrypt from 'bcryptjs';
import stripe from 'stripe';
import grokService from './grok-service';
import veoService from './veo-service';
import crypto from 'crypto';
import cookieParser from 'cookie-parser';
import csurf from 'csurf';
import rateLimit from 'express-rate-limit';
import winston from 'winston';

// Placeholder for sendEmail function
const sendEmail = async (to: string, subject: string, body: string) => {
  console.log(`Sending email to ${to}: Subject - ${subject}, Body - ${body}`);
};

// Placeholder for sendUpsellNotification function
const sendUpsellNotification = async (userId: string, message: string) => {
  console.log(`Sending upsell notification to user ${userId}: ${message}`);
};

// Placeholder for storage.getUserPlan
storage.getUserPlan = async (userId: string) => {
  return 'professional'; // Stub for testing
};

// Environment validation
if (!process.env.SESSION_SECRET) throw new Error('Missing required SESSION_SECRET');
if (!process.env.STRIPE_SECRET_KEY) throw new Error('Missing required STRIPE_SECRET_KEY');
if (!process.env.FACEBOOK_APP_ID) throw new Error('Missing required FACEBOOK_APP_ID');
if (!process.env.XAI_API_KEY) throw new Error('Missing required XAI_API_KEY for Grok');
if (!process.env.GOOGLE_AI_STUDIO_KEY) throw new Error('Missing required GOOGLE_AI_STUDIO_KEY for Veo3');
if (!process.env.DATABASE_URL) throw new Error('Missing required DATABASE_URL for Drizzle/PostgreSQL');
if (!process.env.TWILIO_SID) throw new Error('Missing required TWILIO_SID');
if (!process.env.LINKEDIN_CLIENT_ID) throw new Error('Missing required LINKEDIN_CLIENT_ID');
if (!process.env.X_CLIENT_ID) throw new Error('Missing required X_CLIENT_ID');
if (!process.env.YOUTUBE_CLIENT_ID) throw new Error('Missing required YOUTUBE_CLIENT_ID');
if (!process.env.REDIS_URL) console.warn('REDIS_URL missing - sessions fall back to SQLite, may not scale');

const app = express();

// HTTPS redirect for production
app.use((req, res, next) => {
  if (process.env.NODE_ENV === 'production' && !req.secure) {
    res.redirect(`https://${req.headers.host}${req.url}`);
  } else {
    next();
  }
});

const port = parseInt(process.env.PORT || '5000', 10);
console.log(`Server initializing with port ${port} (${process.env.PORT ? 'from ENV' : 'default'})`);

if (isNaN(port) || port < 1 || port > 65535) {
  console.error(`Invalid port: ${process.env.PORT}. Using default port 5000.`);
  process.exit(1);
}

// Enhanced CORS
app.use(cors({
  origin: true,
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'Accept', 'Origin'],
  optionsSuccessStatus: 200
}));

// CSP middleware
app.use((req, res, next) => {
  res.setHeader('Content-Security-Policy', [
    "default-src 'self'",
    "script-src 'self' 'unsafe-inline' 'unsafe-eval' https: https://replit.com https://*.facebook.com https://connect.facebook.net https://www.googletagmanager.com https://*.google-analytics.com https://*.linkedin.com https://*.twitter.com https://*.youtube.com",
    "connect-src 'self' https: https://graph.facebook.com https://www.googletagmanager.com https://*.google-analytics.com https://analytics.google.com https://api.linkedin.com https://api.twitter.com https://upload.youtube.com",
    "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com",
    "font-src 'self' data: https: https://fonts.gstatic.com https://fonts.googleapis.com blob:",
    "img-src 'self' data: https: https://scontent.xx.fbcdn.net https://www.google-analytics.com",
    "frame-src 'self' https://*.facebook.com",
    "object-src 'none'",
    "base-uri 'self'"
  ].join('; '));
  next();
});

// Body parsing
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Session with Redis fallback
try {
  let store;
  if (process.env.REDIS_URL) {
    const RedisStore = require('connect-redis')(session);
    const redis = require('redis').createClient(process.env.REDIS_URL);
    store = new RedisStore({ client: redis });
  } else {
    const connectSessionKnex = require('connect-session-knex')(session);
    const knex = Knex({
      client: 'sqlite3',
      connection: { filename: './data/sessions.db' },
      useNullAsDefault: true,
    });
    store = new connectSessionKnex({ knex, tablename: 'sessions', createtable: true });
  }
  app.use(session({
    secret: process.env.SESSION_SECRET,
    resave: false,
    saveUninitialized: false,
    store: store,
    cookie: {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      maxAge: 7 * 24 * 60 * 60 * 1000,
      sameSite: 'strict',
      domain: process.env.NODE_ENV === 'production' ? process.env.VERCEL_URL : undefined,
      path: '/'
    },
    name: 'theagencyiq.sid'
  }));
  console.log('✅ Session middleware initialized (SQLite persistent store)');
} catch (error) {
  console.warn('⚠️ SQLite session store failed, falling back to memory store:', error.message);
  app.use(session({
    secret: process.env.SESSION_SECRET,
    resave: false,
    saveUninitialized: false,
    cookie: {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      maxAge: 7 * 24 * 60 * 60 * 1000,
      sameSite: 'strict',
      domain: process.env.NODE_ENV === 'production' ? process.env.VERCEL_URL : undefined,
      path: '/'
    },
    name: 'theagencyiq.sid'
  }));
}

app.use(cookieParser());
app.use(csurf({ cookie: true }));

// Quota middleware
app.use(async (req, res, next) => {
  if (req.session.userId && (req.path.startsWith('/api/post') || req.path.startsWith('/api/generate-content'))) {
    const quota = await quotaManager.checkQuota(req.session.userId);
    if (quota.remaining < 1) return res.status(403).json({ error: 'Quota exceeded - upgrade subscription' });
    const now = new Date();
    const cycleEnd = new Date(quota.cycleStart);
    cycleEnd.setDate(cycleEnd.getDate() + 30);
    if (now > cycleEnd) await quotaManager.resetQuotaCycle(req.session.userId);
  }
  next();
});

// Auto-posting middleware
app.use(async (req, res, next) => {
  if (req.path.startsWith('/api/post')) {
    const platform = req.body.platform;
    const limits = { facebook: 35, instagram: 50, linkedin: 50, x: 100, youtube: 6 };
    const dailyPosts = await storage.countDailyPosts(req.session.userId, platform);
    if (dailyPosts >= limits[platform]) return res.status(429).json({ error: 'Daily limit reached' });
    let attempts = 0;
    while (attempts < 3) {
      try { await postScheduler.postToPlatform(req.body.content, platform); break; } catch { attempts++; await new Promise(r => setTimeout(r, 2 ** attempts * 1000)); }
    }
    if (attempts === 3) return res.status(500).json({ error: 'Posting failed after retries' });
  }
  next();
});

// Session recovery middleware
app.use(async (req: any, res: any, next: any) => {
  const skipPaths = ['/api/establish-session', '/api/webhook', '/manifest.json', '/uploads', '/facebook-data-deletion', '/api/deletion-status', '/auth/', '/oauth-status'];
  if (req.url.startsWith('/auth/facebook') || skipPaths.some(path => req.url.startsWith(path))) return next();
  if (!req.session?.userId) {
    try {
      const sessionId = req.cookies['theagencyiq.sid'];
      if (sessionId) {
        const user = await storage.getUserBySession(sessionId);
        if (user) req.session.userId = user.id;
      }
    } catch (error: any) {
      console.log('Database connectivity issue, proceeding with degraded auth');
    }
  }
  next();
});

// Logout endpoint
app.post('/api/logout', (req, res) => {
  req.session.destroy(err => {
    if (err) return res.status(500).json({ error: 'Logout failed' });
    res.json({ success: true });
  });
});

// Onboarding endpoint
app.post('/api/onboarding', async (req, res) => {
  try {
    const { email, password, phone } = req.body;
    const existing = await storage.getUserByEmail(email);
    if (existing) return res.status(400).json({ error: 'Email in use' });
    const hashedPassword = await bcrypt.hash(password, 10);
    const user = await storage.createUser({ email, hashedPassword, phone });
    const customer = await stripe.customers.create({ email, metadata: { userId: user.id } });
    await storage.updateUser(user.id, { stripeCustomerId: customer.id });
    const verifyToken = crypto.randomBytes(32).toString('hex');
    await storage.updateUser(user.id, { verifyToken });
    await sendEmail(email, 'Verify Email', `Click: ${process.env.APP_URL}/verify?token=${verifyToken}`);
    await twilioService.sendVerification(phone);
    req.session.userId = user.id;
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: 'Onboarding failed' });
  }
});

// Deactivate platform endpoint
app.post('/api/deactivate-platform', async (req, res) => {
  try {
    const { platform } = req.body;
    const endpoints = { facebook: `https://graph.facebook.com/v2.16/${req.session.userId}/permissions`, instagram: 'via Facebook API', linkedin: 'https://api.linkedin.com/v2/accessToken', x: 'https://api.twitter.com/2/oauth2/revoke', youtube: 'https://oauth2.googleapis.com/revoke' };
    await oauthService.revokeTokens(req.session.userId, platform, endpoints[platform]);
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: 'Deactivation failed' });
  }
});

// Generate content endpoint
app.post('/api/generate-content', async (req, res) => {
  try {
    const quota = await quotaManager.checkQuota(req.session.userId);
    if (quota.remaining < 1) return res.status(403).json({ error: 'Quota exceeded - upgrade subscription' });
    const plan = await storage.getUserPlan(req.session.userId);
    if (plan !== 'professional') return res.status(403).json({ error: 'Veo 3.0 exclusive to Professional' });
    const prompt = req.body.prompt + ', JTBD-aligned, animal casting, cinematic';
    const content = await grokService.generateContent(prompt);
    const veoInit = await veoService.initiateVeoGeneration(content, { cinematic: true });
    res.json({ content, video: { isAsync: true, operationId: veoInit.operationId, pollEndpoint: `/api/video/operation/${veoInit.operationId}`, message: 'VEO 3.0 generation initiated - use operation ID to check status', pollInterval: 5000, estimatedTime: '115s to 6 minutes', status: 'processing' } });
  } catch (error) {
    res.status(500).json({ error: 'Content generation failed' });
  }
});

// Video operation poll endpoint
app.get('/api/video/operation/:opId', rateLimit({ windowMs: 5000, max: 1, message: 'Poll too frequent' }), async (req, res) => {
  try {
    const status = await veoService.pollOperationStatus(req.params.opId, req.session.userId);
    if (status.status === 'completed') await quotaManager.deductQuota(req.session.userId, 1);
    res.json(status);
  } catch (error) {
    res.status(500).json({ error: 'Poll failed' });
  }
});

// Stripe webhook endpoint
app.post('/api/stripe-webhook', async (req, res) => {
  try {
    const event = stripe.webhooks.constructEvent(req.body, req.headers['stripe-signature'], process.env.STRIPE_WEBHOOK_SECRET);
    if (event.type === 'customer.subscription.updated') {
      const userId = event.data.object.metadata.userId;
      const plan = event.data.object.plan.name.toLowerCase();
      const quotas = { starter: 10, growth: 20, professional: 30 };
      await quotaManager.updateQuotaFromStripe(userId, quotas[plan]);
      if (event.data.previous_attributes && event.data.previous_attributes.plan.amount > event.data.object.plan.amount) {
        await quotaManager.adjustQuotaOnDowngrade(userId, quotas[plan]);
      }
      if (plan === 'professional') await sendUpsellNotification(userId, 'Upgrade complete - enjoy Veo3!');
    }
    res.json({ received: true });
  } catch (error) {
    res.status(400).json({ error: 'Webhook failed' });
  }
});

// Facebook OAuth error handler
app.use('/auth/facebook/callback', (err: any, req: any, res: any, next: any) => {
  console.error('🔧 Facebook OAuth specific error handler:', err.message);
  if (err.message && err.message.includes("domain of this URL isn't included")) {
    console.error('❌ Facebook OAuth: Domain not configured');
    return res.redirect('/login?error=domain_not_configured&message=Domain+configuration+required+in+Meta+Console');
  }
  if (err.message && (err.message.includes("Invalid verification code") || err.message.includes("verification code"))) {
    console.error('❌ Facebook OAuth: Invalid authorization code');
    return res.redirect('/login?error=invalid_code&message=Facebook+authorization+expired+please+try+again');
  }
  console.error('❌ Facebook OAuth: General error');
  return res.redirect('/login?error=facebook_oauth_failed&message=' + encodeURIComponent(err.message || 'Facebook OAuth failed'));
});

// Global error handler
app.use((err: any, req: any, res: any, next: any) => {
  console.error('Global error handler caught:', err.message || err);
  console.error('Request URL:', req.url);
  console.error('Request method:', req.method);
  console.error('Headers sent:', res.headersSent);
  if (req.url.includes('/auth/facebook/callback') && !res.headersSent) {
    console.error('🔧 Intercepting Facebook OAuth error for graceful handling');
    if (err.message && err.message.includes("domain of this URL isn't included")) {
      console.error('❌ Facebook OAuth: Domain not configured in Meta Console');
      return res.redirect('/login?error=domain_not_configured&message=Domain+configuration+required+in+Meta+Console');
    }
    if (err.message && (err.message.includes("Invalid verification code") || err.message.includes("verification code"))) {
      console.error('❌ Facebook OAuth: Invalid authorization code - graceful redirect');
      return res.redirect('/login?error=invalid_code&message=Facebook+authorization+expired+please+try+again');
    }
    console.error('❌ Facebook OAuth error - graceful redirect:', err.message);
    return res.redirect('/login?error=facebook_oauth_failed&message=' + encodeURIComponent(err.message || 'Facebook OAuth failed'));
  }
  if (!res.headersSent) {
    res.status(500).json({
      error: 'Internal server error',
      message: err.message,
      timestamp: new Date().toISOString(),
      url: req.url
    });
  }
});

// Global logging middleware
const logger = winston.createLogger({ level: 'info', format: winston.format.json(), transports: [new winston.transports.Console()] });
app.use((req, res, next) => {
  logger.info({ path: req.path, method: req.method });
  next();
});
if (process.env.NODE_ENV !== 'production') {
  app.listen(port, () => console.log(`Server running on http://localhost:${port}`));
}

module.exports = app;