Cookie Handling:
Ensure all cookies (e.g., for sessions, auth tokens) are set with Secure, HttpOnly, and SameSite=Strict (or Lax where needed for OAuth redirects) flags to prevent client-side access and cross-site attacks.
Use first-party cookies only; avoid third-party if possible by sharing parent domains (e.g., api.agencyiq.com and www.agencyiq.com).
Limit cookie size (<4KB), scope (specific paths/domains, e.g., Path=/api/refresh), and lifetime (time-limited, non-persistent, tied to OAuth token expiry).
Encrypt cookie data (e.g., AES-256-GCM) and avoid storing sensitive info client-side.
Implement a user-facing cookie consent prompt compliant with laws (e.g., GDPR/ePrivacy). Example text: 'We use essential cookies for login sessions and security. By continuing, you agree to our Cookie Policy. [Accept] [Manage Preferences] [Reject Non-Essential]'. Ensure granular consent (essential vs. analytics) and revocation options.
Fix any broken parts: Check for missing encryption, overbroad domains, or lack of consent banners.
Login Processes:
Verify secure login flows: Use HTTPS everywhere with HSTS, regenerate session IDs post-login to prevent fixation, and integrate MFA (e.g., via email/SMS) for added layers.
For OAuth logins (e.g., connecting social accounts during onboarding), use code flow with PKCE, avoid implicit flow, and handle redirects securely without exposing tokens in URLs.
Onboard new customers securely: During signup, validate inputs, hash passwords (if any) with bcrypt/Argon2, and issue secure session cookies only after verification.
Fix broken parts: Look for plaintext credential storage, missing input sanitization, or weak password requirements.
Session Security and Management:
Generate strong, random session IDs (at least 128 bits, via CSPRNG) and store them server-side (e.g., in Redis or Replit's DB if available).
Implement idle/absolute timeouts (e.g., 15-30 mins), auto-logout on inactivity, and clear cookies/sessions on logout (e.g., res.clearCookie('session_id')).
Monitor for suspicious activity (e.g., IP/user-agent changes) and invalidate sessions/cookies if detected.
Encrypt all session data transfers and regenerate IDs on privilege changes (e.g., after onboarding or quota updates).
Tie into quota management: Sessions should track API usage per user to enforce limits and prevent abuse in auto-posting.
Fix broken parts: Check for missing timeouts, unencrypted sessions, or sessions not invalidated on logout.
Integration with Other Features:
Quota Management: Ensure sessions track per-user quotas for social API calls; invalidate or throttle sessions if limits are hit to prevent bans.
Auto Posting: Secure auto-posting schedules by tying them to validated sessions; use OAuth refresh tokens stored server-side, not in cookies.
Customer Onboarding: Secure flows with session-based progress tracking; use temporary cookies for unfinished onboardings, expiring quickly.
OAuth Everything: For all social integrations, use API-driven cookie issuing via a gateway, protect against token leaks, and handle refreshes backend-only (e.g., on 401 errors, refresh without iframes).
Output Format:

List all identified issues, categorized by area (e.g., Cookies, Login, Sessions), with severity (High/Medium/Low).
For each issue, explain why it's broken/vulnerable and suggest exact code fixes (e.g., Python snippets for Replit, with imports like from flask import session).
Provide an overall readiness assessment: Is it launch-ready? What % fixed? Any compliance gaps?
Suggest tests: E.g., simulate session hijacking or cookie theft.