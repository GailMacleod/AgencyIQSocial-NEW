Here's your "testing prompt"—a self-contained Python script you can copy-paste into a new Replit (use Python template, add Flask if not there via shell: pip install flask redis—wait, Replit allows pip now, but our tool sim says no installs, so assume basics). It tests cookies, sessions, quota simulation, auto-post mock, and OAuth stub. Run it with python main.py (or via Replit run button). It spins a simple Flask app on http://0.0.0.0:8080—hit endpoints like /set-session, /get-session in browser/Postman to verify. If it crashes, that's your broken spot.

python

Collapse

Wrap

Run

Copy
# main.py - AgencyIQ Replit Test Script for Cookies, Sessions, Quotas, Auto-Post, Onboarding/OAuth
# CEO Note: This simulates our app's core—tests persistence, quotas, mocks posting/onboarding. Fix breaks here before video engine.

import os
from flask import Flask, session, request, make_response, jsonify
from datetime import datetime, timedelta
import requests  # For OAuth/post mocks
import json
import time  # For quota delays

# Quota sim: In-memory dict (use Redis in prod for persistence across restarts)
user_quotas = {}  # e.g., {'user_id': {'calls': 0, 'last_reset': datetime.now()}}

app = Flask(__name__)  # Use __name__; Replit handles root_path via env
app.secret_key = os.environ.get('SECRET_KEY', 'supersecretkey')  # Set in Replit env vars for security
app.config['SESSION_COOKIE_SECURE'] = True  # Enforce HTTPS (Replit proxies)
app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'  # Best practice for CSRF
app.config['PERMANENT_SESSION_LIFETIME'] = timedelta(minutes=30)  # Auto-expire

# Mock DB for quotas/sessions (in prod, use Replit DB or SQLite)
def get_quota(user_id):
    if user_id not in user_quotas:
        user_quotas[user_id] = {'calls': 0, 'last_reset': datetime.now()}
    quota = user_quotas[user_id]
    if datetime.now() - quota['last_reset'] > timedelta(days=1):
        quota['calls'] = 0
        quota['last_reset'] = datetime.now()
    return quota

# Test Endpoint: Set Session/Cookie (e.g., store Brand Purpose JTBD)
@app.route('/set-session', methods=['POST'])
def set_session():
    user_id = request.json.get('user_id', 'test_user')
    quota = get_quota(user_id)
    if quota['calls'] >= 5:  # Free tier quota limit
        return jsonify({'error': 'Quota exceeded'}), 429
    quota['calls'] += 1
    
    session['user_id'] = user_id
    session['jtbd'] = request.json.get('jtbd', 'Mental Paris croissant escape')  # Simulate input
    resp = make_response(jsonify({'message': 'Session/Cookie set'}))
    resp.set_cookie']('test_cookie', 'cookie_value', max_age=3600, secure=True, httponly=True)  # Secure cookie
    return resp

# Test Endpoint: Get Session/Cookie (check persistence)
@app.route('/get-session')
def get_session():
    user_id = session.get('user_id', 'unknown')
    jtbd = session.get('jtbd', 'none')
    cookie = request.cookies.get('test_cookie', 'none')
    return jsonify({'user_id': user_id, 'jtbd': jtbd, 'cookie': cookie})

# Test Endpoint: Quota Check (simulate waterfall guidance calls)
@app.route('/quota-check')
def quota_check():
    user_id = session.get('user_id', 'test_user')
    quota = get_quota(user_id)
    return jsonify({'calls_used': quota['calls'], 'quota_left': 5 - quota['calls']})

# Test Endpoint: Mock Auto-Posting (with delay to avoid bans)
@app.route('/auto-post', methods=['POST'])
def auto_post():
    user_id = session.get('user_id')
    if not user_id:
        return jsonify({'error': 'Session required'}), 401
    
    quota = get_quota(user_id)
    if quota['calls'] >= 3:  # Post quota
        return jsonify({'error': 'Post quota exceeded'}), 429
    quota['calls'] += 1
    
    post_data = request.json.get('post', 'Test post to X')
    time.sleep(2)  # Simulate delay for burst prevention
    # Mock post (in prod, use requests to X API)
    mock_response = {'status': 'Posted', 'data': post_data}
    return jsonify(mock_response)

# Test Endpoint: Mock Onboarding/OAuth (stub for CRM pull)
@app.route('/onboard', methods=['GET'])
def onboard():
    code = request.args.get('code')  # Simulate OAuth code from callback
    if not code:
        return jsonify({'error': 'No OAuth code'}), 400
    
    # Mock token exchange (in prod, use requests-oauthlib)
    mock_token = {'access_token': 'fake_token', 'user_data': {'business': 'Bakery Inc', 'goals': '10% sales lift'}}
    session['oauth_token'] = mock_token['access_token']
    return jsonify({'message': 'Onboarded', 'data': mock_token})

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8080, debug=True)  # Replit standard
Test steps in Replit:

Run the app.
POST to /set-session with JSON {'user_id': 'test', 'jtbd': 'escape' } (use curl or browser tool).
GET /get-session—should return stored data (session persists across requests).
Hit /quota-check multiple times—should cap at 5, error on exceed.
POST to /auto-post with JSON {'post': 'Hello X'}—delays, mocks post, respects quota.
GET /onboard?code=fake—mocks OAuth, stores in session.
If this runs stable (no crashes on sessions/quotas), we're good—env is solid. Then send files for full audit, or approve to add video prompt engine (Veo 3 briefs separated). No more back-and-forth; let's fix and ship.